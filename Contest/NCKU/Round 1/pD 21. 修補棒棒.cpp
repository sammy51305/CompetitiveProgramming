/* 這題記得是點跟長度要分開計算
n:被破壞的竹節個數，即洞的數量或說點的數量
m:全部的竹節數量，可理解為長度為m的竹節，每一段長度為1，共m節
k:至多使用的膠帶段數，每一段的長度至少>=1
再來關鍵想法是：
case 1. n <= k的時候，由於欲修補的竹節個數<=修補膠帶的段數，因此直接輸出k段即可(每個點長度都1)

case 2. n > k的時候，先想出勢必會有兩個洞或以上使用到同一段膠帶修復=>再思考要怎麼在有限k段膠帶且比n小的情況下，能夠修補所有的洞
(以下都是case 2)首先，當想要修補n個洞的時候，如果單指看每個洞的話，那麼最直觀的想法就是需要n段(長度為1)的膠帶
因此，得出一個概念：
1.修補完全部的洞，至少需要長度n

再來，有一個神奇的算式：n-k，可以先想成有n個洞，先用n段長度為1的膠帶貼上，但由於只有k段(n > k)，所以會有n-k個間隔的膠帶需要合併
2.找出需要使用同一段膠帶補的個數(n-k)
ex. n=5, k=3
1 2 4 60 87
 1 2 56 27
以此例來看，就會有5個洞，先用5段長度1的膠帶在編號1 2 4 60 87貼上，那麼目前已經使用5段膠帶了，那之後要怎麼變成題目要求的3段膠帶?
以洞與洞之間的間隔來看的話，總共會有4段間隔供選擇，每合併一組(洞與洞)就會讓原本的膠帶段數少一，譬如說假設合併編號1 2的話
那整體用到的膠帶就會是 12(黏一起) 4 60 87共4段膠帶，再黏4跟60：12 460 87就會剩三段膠帶
=>共黏兩組四個洞，也就是n-k。
3.找出滿足使用同一段膠帶連接兩個洞的代價，排序，從最小的代價開始選用。
*/
#include<bits/stdc++.h>
#define endl '\n'
#define ll long long
using namespace std;
ll n, m, k;
vector<ll> s;//spacing
ll ans = 0;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> m >> k;
    if(n == 1){
        cout << 1 << endl;
        return 0;
    }
    s.resize(n-1);
    ll lst, now;
    cin >> lst;
    //記錄洞與洞的間隔長度
    for(int i = 1; i < n; i++){
        cin >> now;
        s[i-1] = now - lst;
        lst = now;
    }

    sort(s.begin(), s.end());
    ans += n;//1.先修補所有的洞
    //2.選擇要合併的間隔，抓最小
    for(int i = 0; i < n-k; i++){
        ans += s[i]-1;
    }
    cout << ans << endl;
    return 0;
}
